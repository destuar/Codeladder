# Task: Allow Taking Exams on Locked Levels

**Goal:** Modify the learning dashboard (`LevelSystem.tsx`) to allow users to click 'Take Exam' on any level, even if it appears locked (dimmed). Passing the exam should still trigger the existing cascading unlock logic.

**Previous Behavior:** The 'Take Exam' and 'See History' buttons were disabled and prevented clicks on levels that were visually dimmed due to the cascading unlock logic.

**New Behavior:** Users can click 'Take Exam' or 'See History' on any level card. The visual dimming still indicates the lock status based on previously passed exams, but interaction is no longer blocked.

**Specific Changes in `frontend/src/components/LevelSystem.tsx`:**

- Removed the `isDimmed && !isComplete` check within the `handleStartNextTest` function that previously prevented navigation to the exam.
- Removed the `isDimmed && !isComplete` check within the `handleTestHistory` function that previously prevented navigation to the history page.
- Removed the `(isDimmed && !isComplete)` condition from the `disabled` prop on the 'Take Exam' button component.
- Removed the `(isDimmed && !isComplete)` condition from the `disabled` prop on the 'See History' button component.
- Removed conditional CSS classes (`bg-gray-100`, `dark:bg-gray-800/40`, `text-muted-foreground`, `cursor-not-allowed`) from both buttons that visually indicated a disabled state when `isDimmed && !isComplete` was true.

# Task: Fix Assessment Timer Duration Display

**Goal:** Ensure the timer displays the correct duration based on the assessment's `estimatedTime` value from the backend, and functions consistently across assessment pages.

**Initial Problem:** Assessment timers consistently displayed a 60-minute duration regardless of the actual `estimatedTime` value set for quizzes and tests in the database. Additionally, the timer would reset when navigating between questions, and the exit confirmation dialog would flicker every second due to timer updates.

**Root Causes Identified:**

1. **Field Name Mismatch:** The frontend components were looking for a `timeLimit` field in the assessment data while the backend was providing it as `estimatedTime`.
2. **Component Re-rendering:** Timer updates every second caused the exit dialog component to re-render and briefly disappear/reappear.
3. **Timer State Management:** The timer state wasn't properly maintained when navigating between assessment pages.

**Specific Changes Implemented:**

**Frontend (`frontend/src/features/assesment/shared/AssessmentEntryPage.tsx`):**

1. **Fixed Field Name Reference:**
   * Changed all references from `assessment.timeLimit` to `assessment.estimatedTime` when setting the `duration` prop for the `AssessmentIntro` and `AssessmentOverview` components.
   * Updated the `initialRemainingTime` calculation to use `assessment.estimatedTime` instead of `assessment.timeLimit`.
   * Added optional chaining (`assessment?.estimatedTime`) to prevent type errors.

2. **Improved Component Performance:**
   * Applied memoization techniques using `useCallback` and `useMemo` to reduce unnecessary re-renders.
   * Memoized the task formatting function (`formatAssessmentTasksCallback`) and the resulting formatted tasks array.
   * Memoized callback handlers (`handleStartAssessment`, `handleProceedToOverview`, `handleExitAssessment`, `handleFinishAssessment`) with proper dependency arrays.

3. **Enhanced Dialog Stability:**
   * Added state for the exit dialog (`showExitDialog`) and lifted it to the parent component to prevent re-rendering issues.
   * Created separate functions for controlling dialog visibility (`handleToggleExitDialog`) and performing the actual exit logic (`performExitNavigation`).

**Frontend (`frontend/src/features/assesment/shared/components/AssessmentPage.tsx`):**

1. **Fixed Field Name Reference:**
   * Updated the `useAssessmentTimer` hook initialization to use `assessment?.estimatedTime` instead of `assessment?.timeLimit`.
   * Added proper state handling to ensure the timer continues from the same point when navigating between assessment views.

2. **Improved Navigation Logic:**
   * Modified the `handleExit` function to include `{ replace: true, state: { skipIntro: true } }` in the navigation call to ensure users return to the assessment overview rather than the intro when exiting from a question.

**Frontend (`frontend/src/features/assesment/shared/components/AssessmentOverview.tsx`):**

1. **Enhanced Component Stability:**
   * Wrapped the `AssessmentOverviewHeader` component in `React.memo` to prevent unnecessary re-renders.
   * Extracted the `AlertDialog` into a dedicated memoized component (`ExitConfirmationDialog`) for better isolation from re-renders.
   * Removed a redundant `useAssessmentTimer` hook call within `AssessmentOverview` that was causing duplicate timer instances.

**Frontend (`frontend/src/features/assesment/shared/hooks/useAssessmentTimer.ts`):**

1. **Added Timer Pausing Capability:**
   * Modified the `useAssessmentTimer` hook to accept a third parameter (`pauseTimer: boolean`) that stops the timer countdown when true.
   * Implemented conditional timer initialization that skips setting up the interval when `pauseTimer` is true.
   * Updated the effect's dependency array to include `pauseTimer` for proper re-execution when the pause state changes.

**Outcome:** The assessment timer now correctly displays the duration based on the database's `estimatedTime` value. The timer remains consistent when navigating between questions, and the exit confirmation dialog remains stable without flickering. This provides a smoother and more accurate user experience across both quiz and test assessments.

# Task: Fix Quiz/Test Results Summary Page Display

**Goal:** Ensure the summary page displayed after completing a quiz or test accurately shows the percentage score, the number of correct vs. total questions, and the time spent.

**Initial Problem:** The summary page consistently displayed "0%" score, "0 time spent", and an incorrect "X out of Y correct" count (e.g., "50 out of 1 correct" instead of "1 out of 2 correct" for a 50% score).

**Root Causes Identified:**

1.  **Incorrect Frontend Mapping:** The frontend components (`QuizResultsPage.tsx` and initially `TestResultsPage.tsx`) were not correctly extracting or calculating values from the API response.
2.  **Missing Backend Data:** The primary API endpoint (`GET /api/quizzes/attempts/:id`) did not originally return the *total* number of questions in the assessment, leading to incorrect denominator calculations on the frontend.
3.  **Inconsistent Backend Field Names:** The backend used `startedAt` while the `TestResultsPage` expected `startTime`, causing issues with time calculation.
4.  **Redundant Frontend Calculation:** `QuizResultsPage.tsx` was attempting to recalculate the percentage score when the backend already provided it.

**Specific Changes Implemented:**

**Backend (`backend/src/routes/quiz.ts`):**

1.  **Modified `GET /api/quizzes/attempts/:id/results` Endpoint:**
    *   Updated Prisma query to include `quiz: { include: { _count: { select: { questions: true } } } }`.
    *   Added `totalQuestions: attempt.quiz?._count?.questions ?? 0` to the returned `results` object.
2.  **Modified `GET /api/quizzes/attempts/:id` Endpoint:**
    *   Updated Prisma query to include `quiz: { include: { _count: { select: { questions: true } } } }`.
    *   Added `totalQuestions: attempt.quiz?._count?.questions ?? 0` to the returned JSON response (`responseWithCount`).
    *   Added pre-calculation of `elapsedTime` based on `completedAt` and `startedAt`.
    *   Added `startTime: attempt.startedAt` as an alias for consistency.
    *   Included `elapsedTime` and `startTime` in the returned JSON response.

**Frontend (`frontend/src/features/assesment/quiz/QuizResultsPage.tsx`):**

1.  **Updated `defaultQuizResult` Mapping:**
    *   Corrected `percentageScore` to use `response.score ?? 0` directly.
    *   Corrected `timeSpentInSeconds` mapping to check `response.timeSpent`, `response.timeTaken`, and added fallback `calculateTimeFromDates(response.startedAt, response.completedAt)`.
    *   Ensured `totalQuestions` correctly uses `response.totalQuestions` (now provided by the backend).
2.  **Added `calculateTimeFromDates` Helper Function:** Implemented this function to calculate duration from date strings.
3.  **Fixed Score Display Text:** Modified the display logic to use `result.questions?.filter(q => q.correct).length || 0` for the count of correct answers and `result.totalQuestions || 0` for the total number of questions.
4.  **Added Debug Logging:** Included `console.log` statements to show processed result values.

**Frontend (`frontend/src/features/assesment/test/TestResultsPage.tsx`):**

1.  **Updated `totalQuestions` Calculation:** Modified the variable assignment to prioritize `testResult?.totalQuestions` (now provided by the backend via the updated `/attempts/:id` endpoint) before falling back to `testResult?.responses?.length`.
2.  **Added Debug Logging:** Included `console.log` statements similar to the quiz page.

**Outcome:** Both quiz and test summary pages now accurately display the percentage score, the correct vs. total question count, and the time spent.

# Task: Fix Assessment Submitted Status Lost on Navigation

**Goal:** Ensure that when a user submits an answer for an individual question (MCQ or Code) within a quiz or test, navigates away from the assessment page, and then returns, the question correctly displays both its 'Submitted' status and the previously selected answer.

**Initial Problem:** After submitting a question, navigating away (e.g., back to the assessment overview) and then back into the question, the 'Submitted âœ“' button state persisted, but the visual indication of the selected answer (e.g., the filled radio button for MCQ) was lost.

**Root Cause:** A state synchronization issue in `AssessmentPage.tsx`. When the page reloaded upon navigation, the `submittedQuestions` state array (tracking which questions were submitted) was correctly reloaded from `sessionStorage`. However, the `answers` prop (containing the actual selected answers, passed down from `useQuiz` or `useTest`) was sometimes stale or empty during the initial render cycles after navigating back. This led to the question component (`MultipleChoiceQuestion` or `CodeQuestion`) rendering without the selection, even though the `AssessmentPage` knew the question was submitted.

**Specific Fixes:**

1.  **Refactored State Initialization in `AssessmentPage.tsx`:**
    *   Modified `useEffect` hooks to prioritize loading `submittedQuestions` state directly from `sessionStorage` on mount using a helper function (`loadInitialSubmittedQuestions`).
    *   Separated effects for different initialization phases (completion checks, attempt starting, `assessment_${id}` structure verification) to prevent race conditions.
    *   Ensured the `assessment_${id}` structure creation/verification relies on the correctly loaded state and doesn't incorrectly overwrite `isSubmitted` flags.

2.  **Synchronized `useTest.ts` with `useQuiz.ts`:**
    *   **Identified Discrepancy:** Found that `useTest.ts` had diverged from `useQuiz.ts` and was not correctly restoring the `answers` state object from `sessionStorage` upon re-initialization (like when navigating back).
    *   **Replaced Logic:** Copied the entire working logic from `useQuiz.ts` into `useTest.ts`, meticulously renaming all quiz-specific identifiers (variables, types, storage keys like `quiz_` -> `test_`) to their test equivalents.
    *   **Fixed Linter Error:** Corrected a minor linter error introduced during the copy by ensuring the `resetTestSession` helper function was defined before being used within its `useEffect` hook.

**Outcome:** Both quizzes and tests now correctly restore and display the selected answer *and* the submitted status when navigating back to a previously answered question.

# Task: Fix Test Question Update Failing (404 Error)

**Goal:** Allow administrators to successfully update questions within a Test via the Admin Dashboard.

**Initial Problem:** When attempting to save changes to a question belonging to a Test, the frontend sent a `PUT` request to `/api/quizzes/questions/:questionId`, resulting in a `404 Not Found` error from the backend.

**Root Cause:** The frontend code in `TestAdmin.tsx` was incorrectly calling the `api.updateQuizQuestion` function, which is hardcoded to use the API endpoint specifically designed for *quiz* questions. The backend couldn't find the *test* question at that quiz-specific URL.

**Specific Fixes:**

1.  **Added `updateTestQuestion` to `api.ts`:**
    *   Created a new function `updateTestQuestion` in the API client (`frontend/src/lib/api.ts`).
    *   This new function sends `PUT` requests to the correct endpoint for test questions (assumed `/api/tests/questions/:questionId`).
2.  **Updated `TestAdmin.tsx`:**
    *   Modified the `handleSaveTest` function within `frontend/src/features/admin/components/TestAdmin.tsx`.
    *   Changed the code to call the newly added `api.updateTestQuestion` function when updating an existing question, instead of the incorrect `api.updateQuizQuestion`.

**Outcome:** Updating existing questions within a Test from the Admin Dashboard now sends the request to the correct backend endpoint and succeeds.

# Task: Suppress Harmless Console Warning on Test Deletion

**Goal:** Prevent a benign console warning about JSON parsing when deleting a test from the Admin Dashboard.

**Initial Problem:** Successfully deleting a Test triggered a console warning: `SyntaxError: Unexpected end of JSON input`, even though the delete operation worked correctly.

**Root Cause:** The backend correctly responds to a successful `DELETE` request with an HTTP `204 No Content` status, which has an empty body. The generic `request` function in the frontend API client (`frontend/src/lib/api.ts`) was unconditionally attempting to parse *all* response bodies as JSON, leading to an error when trying to parse the intentionally empty body of the `204` response.

**Specific Fix:**

1.  **Modified `request` function in `api.ts`:**
    *   Added a check within the `request` function to specifically look for `response.status === 204`.
    *   If the status is `204`, the function now skips the `response.json()` call, preventing the parsing error on the empty body.

**Outcome:** Deleting tests no longer produces the harmless JSON parsing warning in the console.

# Task: Remove Action Buttons from Test Results Page

**Goal:** Remove the "Return to Level" and "Retake Test" buttons from the bottom of the test results page.

**Request:** User explicitly asked to remove these buttons.

**Specific Fix:**

1.  **Commented out JSX in `TestResultsPage.tsx`:**
    *   Located the `div` containing the "Return to Level" and "Retake Test" buttons near the end of `frontend/src/features/assesment/test/TestResultsPage.tsx`.
    *   Commented out this entire block of JSX code.

**Outcome:** The specified buttons are no longer displayed on the test results page.

# Task: Stabilize Assessment Timer and Session State

**Goal:** Ensure the quiz/test timer initializes correctly with the fetched `estimatedTime`, persists accurately across navigation between assessment pages (overview, MCQ, code), and that assessment state (answers, submitted status) is reliably loaded and cleared.

**Initial Problem:**
1.  **Incorrect Initial Timer:** On first load of an assessment page (especially after navigating from overview to a question), the timer often briefly showed the default 60 minutes or reset to the full `estimatedTime` instead of continuing the countdown from its previous state.
2.  **State Inconsistency:** Occasionally, previously submitted answers or the 'Submitted' status from a *prior* attempt on the *same* quiz/test would incorrectly persist into a new attempt.

**Root Causes Identified:**

1.  **Timer Initialization Race Condition:** The `useAssessmentTimer` hook was initializing based on the `initialDuration` prop *before* confirming if a valid time already existed in `sessionStorage` for the current attempt. This happened because the hook ran immediately on mount, potentially before the parent component (`AssessmentPage`) had finished loading the `assessment` data containing the correct `estimatedTime` or before `sessionStorage` could be reliably read and prioritized.
2.  **Conflicting State Management:** The `AssessmentPage` component contained logic within a `useEffect` hook that attempted to read and sometimes write the `remainingTime` field within the `assessment_{id}` session storage item. This conflicted with `useAssessmentTimer`, which should have been the sole owner of that field.
3.  **Incomplete/Inconsistent Session Cleanup:** The logic for clearing `sessionStorage` upon completion, explicit exit, or starting a new attempt after a prior completion was fragmented across different components and hooks (`AssessmentEntryPage`, `useQuiz`, `useTest`, `AssessmentOverviewHeader`), leading to scenarios where old state wasn't fully purged.

**Specific Changes Implemented:**

**Frontend (`frontend/src/lib/sessionUtils.ts`):**
1.  **Created Centralized Utilities:**
    *   `clearAssessmentSession(assessmentId, type)`: Thoroughly removes all known session keys related to a specific assessment ID and type.
    *   `markAssessmentCompleted(assessmentId, type)`: Sets a specific flag (`${type}_${assessmentId}_completed`) in session storage.
    *   `isAssessmentCompleted(assessmentId, type)`: Checks for the existence of the completion flag.

**Frontend (`frontend/src/features/assesment/shared/hooks/useAssessmentTimer.ts`):**
1.  **Stricter Initialization:**
    *   Modified the initialization `useEffect` to *always* prioritize `loadTimeFromStorage()`. If a stored time is found, it's used, and further initialization logic within that effect run is skipped.
    *   Initialization using `initialDuration` only occurs if *no* stored time exists *and* a valid (`> 0`) `initialDuration` is provided.
    *   Removed the fallback to a default 60 minutes if `initialDuration` wasn't ready; the hook now waits.
    *   Ensured the interval only starts if `remainingTime` has been successfully set (is not `undefined`).
    *   Improved logging for debugging initialization steps.

**Frontend (`frontend/src/features/assesment/shared/components/AssessmentPage.tsx`):**
1.  **Delayed Timer Initialization:**
    *   Added an `isReady` state variable, set to true only after the `assessment` data (containing `estimatedTime`) finishes loading (`isLoading` is false).
    *   The `useAssessmentTimer` hook is now passed `isReady ? id : undefined` for its `assessmentId` parameter, ensuring it only starts processing when the necessary data is available.
2.  **Removed Conflicting Logic:**
    *   Deleted all code within the `useEffect` hook responsible for initializing/verifying the `assessment_{id}` session structure that attempted to read or write the `remainingTime` field. This responsibility is now solely with `useAssessmentTimer`.
    *   Ensured the effect still correctly syncs task structures and submitted counts.

**Frontend (`frontend/src/features/assesment/shared/AssessmentEntryPage.tsx`):**
1.  **Integrated Session Utilities:**
    *   The initial `useEffect` now uses `isAssessmentCompleted` to check for prior completion and calls `clearAssessmentSession` if true *before* attempting to load any resumable state.
    *   The `performExitNavigation` function (called on confirmed exit) now uses `clearAssessmentSession`.
    *   The `handleFinishAssessment` function (called on confirmed submission) now correctly uses `markAssessmentCompleted` and `clearAssessmentSession` upon successful API submission.

**Frontend (`frontend/src/features/assesment/quiz/hooks/useQuiz.ts` & `frontend/src/features/assesment/test/hooks/useTest.ts`):**
1.  **Integrated Session Utilities:**
    *   Refactored initialization (`useEffect`), submission (`submitQuiz`/`submitTest`), attempt starting (`startQuizAttempt`/`startTestAttempt`), and reset logic (`clearSavedQuiz`/`clearSavedTest`, `forceReset`) to consistently use `isAssessmentCompleted`, `markAssessmentCompleted`, and `clearAssessmentSession`.
    *   Removed redundant manual session key removal logic.
    *   Fixed linter error in `useQuiz` by using the correct `api.submitQuizResponse` function.

**Frontend (`frontend/src/features/assesment/shared/components/AssessmentOverview.tsx`):**
1.  **Integrated Session Utilities:**
    *   Updated the `AssessmentOverviewHeader`'s `handleExitConfirm` function to use `clearAssessmentSession`.
    *   Corrected import path for `clearAssessmentSession`.
2.  **Improved Display:**
    *   Updated `formatRemainingTime` to handle `undefined` and `<= 0` cases gracefully.
    *   Added a 'Loading...' state for the duration display when `duration` prop is initially undefined.

**Frontend (`frontend/src/features/assesment/shared/components/AssessmentIntro.tsx`):**
1.  **Improved Display:**
    *   Updated `formatDuration` to handle `undefined`, `null`, and `<= 0` cases gracefully.

**Outcome:** The assessment timer now reliably initializes with the correct time fetched from the backend, persists its state correctly during navigation between overview and question pages, and avoids resetting inappropriately. Furthermore, the session state for quizzes and tests is managed more robustly, preventing issues with stale data from previous attempts interfering with new ones.

# Task: Prevent Quiz Title Flicker on Intro Page

**Goal:** Ensure the quiz introduction page displays the *Topic Name* (e.g., "Methodology") directly as the title, instead of briefly showing the *Quiz Name* (e.g., "Quiz #4") and then switching.

**Initial Problem:** The quiz intro page title would flicker. It initially displayed the quiz name fetched with the main assessment data, then updated to the topic name once the separate topic data fetch completed.

**Root Cause:** The `AssessmentEntryPage.tsx` component rendered the `AssessmentIntro.tsx` subcomponent using fallback data (`assessment.title`) while still waiting for the `useQuery` hook fetching the related `topic` data (which contained the correct `topic.name`) to resolve.

**Specific Changes Implemented:**

**Frontend (`frontend/src/features/assesment/shared/AssessmentEntryPage.tsx`):**

1.  **Added Loading State Check:**
    *   Inside the `if (showIntro)` block, added a condition `if (isQuiz && topicLoading)`. This checks if the assessment is a quiz and if the `useQuery` fetching the topic data is still in its loading state.
2.  **Implemented Skeleton Loader:**
    *   When the above condition is true (quiz intro, topic loading), the component now returns a `Skeleton` loading UI placeholder instead of rendering `AssessmentIntro` immediately.
3.  **Delayed Rendering & Updated Title Prop:**
    *   Ensured that `AssessmentIntro` is only rendered for quizzes *after* the `topicLoading` state is false.
    *   Modified the `title` prop passed to `AssessmentIntro` for quizzes to prioritize the now-loaded topic name: `title={isQuiz ? (topic?.name || 'Quiz Topic') : ...}`. The fallback to `assessment.title` for quizzes was removed, as the loading check guarantees `topic.name` is available (or a default is used).

**Outcome:** The quiz introduction page now displays a loading indicator if the topic data isn't immediately available, and then renders directly with the correct topic name as the title, eliminating the distracting flicker.

# Task: Enforce Single Correct Answer for MC Questions in Admin

**Goal:** Prevent administrators from marking more than one option as correct for a multiple-choice question when creating or editing Quizzes or Tests.

**Initial Problem:** The admin interface allowed selecting multiple checkboxes for 'Correct Answer' in the MC question editor.

**Root Cause:** The `Checkbox` component's `onCheckedChange` handler only toggled the state of the clicked option, without deselecting others.

**Specific Changes Implemented:**

**Frontend (`frontend/src/features/admin/components/QuizAdmin.tsx`):**

1.  **Modified `onCheckedChange` Handler:**
    *   Located the `Checkbox` component within the `mcOptions.map` loop inside the problem editing dialog.
    *   Updated its `onCheckedChange` handler. The new logic ensures that when an option's checkbox is checked (marked as correct), all other options in the `mcOptions` state array are automatically set to `isCorrect: false`.

**Frontend (`frontend/src/features/admin/components/TestAdmin.tsx`):**

1.  **Modified `onCheckedChange` Handler:**
    *   Applied the identical modification to the `onCheckedChange` handler for the corresponding `Checkbox` component within the multiple-choice options section of the problem editing dialog.

**Outcome:** Both Quiz and Test admin interfaces now correctly enforce a single-select behavior for the 'Correct Answer' checkbox on multiple-choice questions, ensuring data integrity.

# Task: Remove Difficulty Field from Admin UI

**Goal:** Remove the 'Difficulty' field from the Quiz and Test question editing interfaces in the Admin Dashboard.

**Initial Problem:** Quiz and Test questions had a 'Difficulty' field (Easy/Medium/Hard) that was no longer needed.

**Root Cause:** The field existed in the frontend state and UI components.

**Specific Changes Implemented:**

**Frontend (`frontend/src/features/admin/components/QuizAdmin.tsx`):**

1.  **Removed State:** Deleted the `problemDifficulty` state variable.
2.  **Removed UI Elements:**
    *   Removed the 'Difficulty' `<Select>` dropdown from the problem editing dialog (for both MC and Code question types).
    *   Removed the 'Difficulty' badge displayed in the list of questions for a quiz.
3.  **Removed Data Handling:** Removed logic that set or used the `problemDifficulty` state when initializing the edit form or saving a problem.

**Frontend (`frontend/src/features/admin/components/TestAdmin.tsx`):**

1.  **Removed State:** Deleted the `problemDifficulty` state variable.
2.  **Removed UI Elements:**
    *   Removed the 'Difficulty' `<Select>` dropdown from the problem editing dialog (for both MC and Code question types).
    *   Removed the 'Difficulty' badge displayed in the list of questions for a test.
3.  **Removed Data Handling:** Removed logic that set or used the `problemDifficulty` state when initializing the edit form or saving a problem.

**Backend/Schema:** No changes were made. The `difficulty` field remains optional (`String?`) in the `QuizQuestion` model in `schema.prisma`.

**Outcome:** The 'Difficulty' field is no longer visible or editable in the Quiz and Test admin interfaces. When questions are saved, the `difficulty` field will be null or absent, which is permitted by the existing database schema.

# Task: Remove Quiz Display Order Field from Admin UI

**Goal:** Remove the unused 'Display Order' field from the Quiz creation/edit dialog in the Admin Dashboard.

**Initial Problem:** The Quiz editor included a 'Display Order' field, but the quiz selection logic does not use this order.

**Root Cause:** The field existed in the frontend state and UI components for the Quiz editor.

**Specific Changes Implemented:**

**Frontend (`frontend/src/features/admin/components/QuizAdmin.tsx`):**

1.  **Removed State:** Deleted the `quizOrderNum` state variable.
2.  **Removed UI Element:** Removed the 'Display Order' `Input` field and its `Label` from the Quiz editor dialog.
3.  **Removed Data Handling:** Removed logic that set or used the `quizOrderNum` state when initializing the edit form or saving a quiz.

**Outcome:** The 'Display Order' field is no longer present in the Quiz admin interface, aligning the UI with the application logic.

# Task: Make Description and Estimated Time Required Fields

**Goal:** Ensure 'Description' and 'Estimated Time' are required fields when creating or editing Quizzes and Tests.

**Initial Problem:** These fields were optional in the Test editor and only Description was required in the Quiz editor.

**Root Cause:** Missing required indicators (`*`) on labels, presence of "(Optional)" text/placeholders, and incomplete validation logic.

**Specific Changes Implemented:**

**Frontend (`frontend/src/features/admin/components/QuizAdmin.tsx`):**

1.  **Updated Label:** Added required indicator (`*`) to the 'Estimated Time' label.
2.  **Updated Validation:** Modified `handleSaveQuiz` to add a check ensuring `estimatedTime` is provided and is a positive number.

**Frontend (`frontend/src/features/admin/components/TestAdmin.tsx`):**

1.  **Updated Labels:**
    *   Added required indicator (`*`) to the 'Description' label and removed "(Optional)".
    *   Added required indicator (`*`) to the 'Estimated Time' label.
2.  **Updated Placeholder:** Removed "Optional" placeholder from the 'Estimated Time' input field.
3.  **Updated Validation:** Modified `handleSaveTest` to add checks ensuring `testDescription` is not empty and `estimatedTime` is provided and is a positive number.

**Outcome:** Both Quiz and Test admin editors now clearly mark Description and Estimated Time as required fields and enforce this requirement through validation before saving.

# Task: Implement Drag-and-Drop Question Reordering

**Goal:** Allow administrators to reorder questions within a Quiz or Test using drag-and-drop in the respective editor dialogs.

**Initial Problem:** Questions could only be ordered implicitly by the sequence they were added, with no way to change the order after creation.

**Root Cause:** Lack of reordering mechanism in the UI and logic.

**Specific Changes Implemented:**

1.  **Dependency Added:** Installed `@hello-pangea/dnd` library in the `frontend` project.
2.  **Quiz Editor (`frontend/src/features/admin/components/QuizAdmin.tsx`):**
    *   Imported `DragDropContext`, `Droppable`, `Draggable`, `DropResult` from `@hello-pangea/dnd`.
    *   Added `handleOnDragEnd` function to update `quizProblems` state array order and re-assign `orderNum` property based on the new index after a drag operation.
    *   Wrapped the question list container in `<DragDropContext>` and `<Droppable>`.
    *   Wrapped each question item in the `.map()` loop with `<Draggable>` and applied necessary props (`innerRef`, `draggableProps`, `dragHandleProps`).
    *   Updated `handleSaveQuiz` to ensure the `orderNum` sent to the backend reflects the final index in the `quizProblems` state array.
    *   Removed the `problemOrderNum` state variable.
    *   Removed the manual "Order" input field from the problem editing dialog.
    *   Updated the `handleSaveProblem` function (used for local state updates) to remove any `orderNum` assignment.
3.  **Test Editor (`frontend/src/features/admin/components/TestAdmin.tsx`):**
    *   Applied the identical changes as listed above for `QuizAdmin.tsx`, modifying `testProblems`, `handleSaveTest`, and `handleSaveProblem` accordingly.
    *   Removed the `problemOrderNum` state variable and the manual "Order" input from the problem dialog.

**Outcome:** Administrators can now visually reorder questions within the Quiz and Test editor dialogs using drag-and-drop. The displayed order number updates dynamically, and the correct order is saved to the backend.

# Task: Fix DND Nested Scroll Container Warning

**Goal:** Eliminate the console warning "@hello-pangea/dnd: unsupported nested scroll container detected" in the Quiz and Test editor dialogs.

**Initial Problem:** The warning appeared because the question list (`Droppable` area) had its own scroll settings (`max-h`, `overflow-y-auto`) while being inside the main dialog content area, which is also scrollable.

**Root Cause:** Nested scroll containers are not fully supported by the drag-and-drop library and cause conflicts in scroll calculation during drag operations.

**Specific Changes Implemented:**

**Frontend (`frontend/src/features/admin/components/QuizAdmin.tsx` & `frontend/src/features/admin/components/TestAdmin.tsx`):**

1.  **Removed Inner Scrolling:** Located the `div` element directly inside the `<Droppable>` component that previously had `max-h-[300px]`, `overflow-y-auto`, and `pr-1` classes.
2.  Removed these classes (`max-h-[300px]`, `overflow-y-auto`, `pr-1`) from the aforementioned `div` in both files.

**Outcome:** The question list no longer attempts to manage its own scrollbar. Scrolling is now handled entirely by the outer `DialogContent` container, resolving the nested scroll conflict and eliminating the console warning.

# Task: Debug Missing Questions During Quiz Attempt

**Goal:** Identify why questions successfully saved in the Quiz Admin interface were not appearing when a user attempts to take the quiz.

**Initial Problem:** After adding or editing questions in the Quiz Admin dialog and receiving successful save confirmations (200 OK responses for metadata and question updates), the questions were absent when starting a new attempt of that quiz.

**Debugging Steps:**

1.  **Verified Save Process:** Reviewed frontend console logs (`QuizAdmin.tsx`). Confirmed that:
    *   The initial load of existing questions was correct.
    *   The `PUT` request to update quiz metadata (`/api/quizzes/:id`) returned 200 OK.
    *   The `PUT` requests to update individual questions (`/api/quizzes/questions/:questionId`) returned 200 OK.
    *   The list refresh after saving also returned 200 OK.
    *   Conclusion: The frontend save and backend acknowledgment seemed successful.

2.  **Hypothesized Retrieval Issue:** Deduced the problem likely occurred when *fetching* the quiz data for a new attempt, specifically within the `GET /api/quizzes/:id/attempt` backend endpoint.

3.  **Directed Backend Log Check:** Instructed user to attempt the affected quiz and check the **backend server console** for a specific `DEBUG:` log message within the `GET /api/quizzes/:id/attempt` handler. This log was added previously to show either the structure of the first question being sent or a message indicating no questions were found/sent.

**Current Status:** Waiting for user to provide the output of the backend debug log to determine if the questions are being fetched correctly from the database but potentially lost during transformation, or if they are not being fetched at all for the attempt.

# Task: Fix Quiz Question Duplication During Creation

**Goal:** Prevent quiz questions from being duplicated (doubled) when creating a new quiz in the Admin Dashboard.

**Initial Problem:** When administrators created a new quiz with questions (e.g., 3 questions), the system was saving duplicate entries (e.g., 6 questions) to the database.

**Root Cause:** The `handleSaveQuiz` function in `QuizAdmin.tsx` was creating questions twice:
1. First, during the initial quiz creation via `api.createQuiz({...quizMetadata, problems: preparedProblems }, token)` which was designed to create both the quiz and its questions in a single transaction.
2. Second, immediately after, the code incorrectly proceeded to the question-specific creation step (intended only for edit mode), resulting in the same questions being created again via individual `api.createQuizQuestion` calls.

**Specific Fix:**
1. Completely restructured the logic flow in `handleSaveQuiz`:
   - For CREATE mode: Only use the single `api.createQuiz` call that handles creating both the quiz and all its questions in one transaction.
   - For EDIT mode: First update quiz metadata, then handle question updates/creations/deletions individually.
2. Moved all the question processing logic (deletions, creations, updates) inside the edit mode conditional block to ensure it only runs when editing an existing quiz.
3. Added clear comments to distinguish between CREATE mode and EDIT mode code paths.

**Additional Fix:**
1. Removed a toast error notification in `fetchQuizzesForTopic` that was displaying "Failed to load quizzes for topic" when no quizzes were found, as this was a valid state rather than an error condition.

**Outcome:** Creating a new quiz now correctly saves questions exactly once, and the UI no longer shows misleading error notifications when a topic has no quizzes.

# Task: Fix Timer Display in Assessment Header/Sidebar

**Goal:** Ensure the main timer displayed in the assessment header and sidebar (`AssessmentHeader`, `QuizSidebar`) reflects the correct remaining time after the `useAssessmentTimer` hook was refactored.

**Initial Problem:** Following the refactor of `useAssessmentTimer` (where it now requires an explicit `startTimer` call and manages its own running state), the timer display in the header and sidebar components within `AssessmentPage.tsx` stopped updating. It showed the initial time but didn't count down.

**Root Cause:** The `AssessmentPage.tsx` component was not correctly utilizing the updated `useAssessmentTimer` hook. It was only destructuring `remainingTime` and not using the other values like `isRunning`. An attempt to pass the hook's `formattedTime` (string) directly to the header/sidebar failed because those components expected a number. Additionally, the hook was being initialized before the necessary `assessment` data (containing `estimatedTime`) was fully loaded.

**Specific Changes Implemented:**

**Frontend (`frontend/src/features/assesment/shared/components/AssessmentPage.tsx`):**

1.  **Updated Hook Usage:**
    *   Destructured all relevant values from `useAssessmentTimer`: `remainingTime`, `formattedTime`, `isRunning`, `pauseTimer`, `resetTimer`.
    *   Passed the raw `remainingTime` numerical value (defaulting to `0` if `null`) to the `elapsedTime` prop of `AssessmentHeader` and `QuizSidebar`.
    *   Removed the redundant `pause` prop from the `useAssessmentTimer` call, as the hook now manages its running state internally.
2.  **Delayed Initialization:**
    *   Added an `isReady` state variable that becomes true only after the `assessment` data is confirmed loaded (`isLoading` is false).
    *   Modified the `useAssessmentTimer` hook call to only pass the `assessmentId` when `isReady` is true (`isReady ? id : undefined`). This prevents the hook from trying to initialize before `estimatedTime` is available.

**Outcome:** The `useAssessmentTimer` hook is now correctly instantiated and managed within `AssessmentPage`. The raw `remainingTime` (number) is passed down, allowing the `AssessmentHeader` and `QuizSidebar` components to display the countdown accurately as the hook's state updates.

# Task: Admin UI Consistency and Fixes (Quizzes & Tests)

**Goal:** Improve consistency and fix bugs in the Quiz and Test admin interfaces.

**Specific Changes Implemented:**

**Frontend (`frontend/src/features/admin/components/TestAdmin.tsx`):
*   Fixed non-functional "Add Option" button for MC questions by replacing the rendering logic with the working version from `QuizAdmin.tsx`.
*   Removed the individual explanation input field for each MC answer option.
*   Removed the `explanation` property from the `McOption` interface and associated saving logic.
*   Removed the container border (`border`, `rounded-md`) around the MC options list.
*   Removed the divider lines (`border-b`) between MC options.
*   Verified/ensured the `onCheckedChange` handler for the MC "Correct Answer" checkbox enforces single selection.
*   Updated Edit/Delete buttons on the main Test list to include text labels and match the smaller style used in `QuizAdmin.tsx`.
*   Removed the `ClipboardCheck` icon next to test names in the list.

**Frontend (`frontend/src/features/admin/components/QuizAdmin.tsx`):
*   Changed the problem dialog save button text from "Update/Add Problem Locally" to "Update/Add Question".
*   Moved the "Add Option" button for MC questions above the options list (top-right).
*   Removed the individual explanation input field for each MC answer option.
*   Removed the `explanation` property from the `McOption` interface and associated saving logic.
*   Removed the container border (`border`, `rounded-md`) around the MC options list.
*   Removed the divider lines (`border-b`) between MC options.
*   Corrected the `onCheckedChange` handler for the MC "Correct Answer" checkbox to enforce single selection.
*   Added the "Correct" text label next to the MC "Correct Answer" checkbox.
*   Updated the metadata display (Pass %, Time, Questions) for each quiz in the list to use icons and formatting consistent with `TestAdmin.tsx`.
*   Changed the question Edit/Delete buttons within the editor dialog to be icon-only.
*   Ensured the "Add Question" button within the editor dialog uses the `outline` variant.
*   Changed the "Add Quiz" button icon from `PlusCircle` to `Plus`.
*   Changed the main "Refresh Path" button text to "Refresh".
*   Removed the small refresh icon button from individual topic card headers.

**Outcome:** The Quiz and Test admin interfaces are now more visually and functionally consistent, with several UI bugs related to MC option management resolved. Individual answer explanations have been removed, favoring the global explanation.

# Task: Fix Assessment Overview Icon Display Issue

**Goal:** Ensure MCQ and Code icons consistently appear next to questions listed on the assessment overview page (`AssessmentEntryPage`).

**Initial Problem:** Icons indicating question type (MCQ/Code) sometimes disappeared upon navigating back to the overview page after viewing a question. Console warnings like "Unrecognized task type: Unknown, returning default icon" appeared in `AssessmentOverview.tsx`.

**Root Cause:** A combination of issues:
1.  **Incorrect Type Formatting:** Initially, `AssessmentEntryPage.tsx` formatted backend types (`MULTIPLE_CHOICE`, `CODE`) into display strings (`'Multiple Choice'`, `'Code'`) before passing them to `AssessmentOverview`. The `getTaskIcon` function in `AssessmentOverview` didn't recognize these display strings.
2.  **Stale State Restoration:** Even after fixing the formatting, the issue persisted on navigation *back* to the overview. `AssessmentEntryPage` was restoring state from `sessionStorage` (key `assessment_{id}`) and prioritized the `type` field from this potentially stale/incorrect saved data over the freshly fetched API data.
3.  **Conflicting State Management:** `AssessmentOverview.tsx` also contained its own `useEffect` hook reading and writing to the same `assessment_{id}` session storage key, creating potential race conditions and state conflicts with `AssessmentEntryPage`.

**Specific Fixes Implemented:**

**Frontend (`frontend/src/features/assesment/shared/AssessmentEntryPage.tsx`):**
1.  **Corrected Type Handling:** Modified `formatAssessmentTasksCallback` to *always* use the original `question.questionType` obtained from the fresh API fetch (`assessment.questions`). The initial incorrect formatting to display strings was removed.
2.  **Robust State Restoration:** Updated the logic for restoring state from `sessionStorage`. When `savedTasks` are present, the component now only restores status fields like `isSubmitted` and `isViewed` from the saved data, while ensuring the `type` and `maxScore` always come from the fresh API data (`assessment.questions`).

**Frontend (`frontend/src/features/assesment/shared/components/AssessmentOverview.tsx`):**
1.  **Removed State Management:** Deleted the local state (`localTasks`, `localSubmittedCount`) and the `useEffect` hook that interacted with `sessionStorage`. The component now relies solely on the `tasks` and `submittedCount` props passed down from `AssessmentEntryPage`.
2.  **Corrected `getTaskIcon`:** Ensured the `getTaskIcon` function correctly checks the received `task.type` against the expected backend values (`multiple_choice`, `code`) using case-insensitive comparison.

**Outcome:** Icons now display reliably on the assessment overview page, using the correct `questionType` sourced directly from the API fetch managed by `AssessmentEntryPage`. Stale session data no longer interferes with the type display, and conflicting state management between the two components has been eliminated.

# Task: Fix MC Option Shuffling Consistency

**Goal:** Ensure that when Multiple Choice (MC) question options are set to shuffle (`shuffleOptions: true`), they are shuffled only *once* when the quiz/test begins and remain in that shuffled order throughout the user's attempt, even when navigating between questions.

**Initial Problem:** MC options, if set to shuffle, were being re-shuffled every time the `MultipleChoiceQuestionComponent` rendered. This occurred when navigating back and forth between questions, leading to an inconsistent user experience.

**Root Cause:** The shuffling logic (`Math.random()`) was implemented directly within the `MultipleChoiceQuestionComponent` using `React.useMemo`. This memo hook would re-run (and re-shuffle) whenever the component's props or state changed in a way that triggered re-rendering, including navigation events.

**Specific Fixes Implemented:**

1.  **Moved Shuffling to Parent Hooks:**
    *   The primary shuffling logic was relocated from `MultipleChoiceQuestionComponent.tsx` to the parent hooks responsible for fetching and managing the assessment data: `useQuiz.ts` and `useTest.ts`.
2.  **One-Time Shuffle on Load:**
    *   Added a `useMemo` hook within both `useQuiz.ts` and `useTest.ts`. This hook takes the raw quiz/test data fetched from the API.
    *   Inside the `useMemo`, it creates a deep clone of the data.
    *   It then iterates through the questions in the cloned data. If a question is `MULTIPLE_CHOICE` and has `shuffleOptions: true`, its `mcProblem.options` array is shuffled *at this point* using a Fisher-Yates algorithm (`shuffleArray` helper function).
    *   This `useMemo` hook returns the processed data (with options shuffled only where applicable).
    *   The rest of the `useQuiz` and `useTest` hooks were updated to use this `processedQuiz` / `processedTest` data instead of the raw fetched data. This ensures the shuffled order is established once and maintained in the hook's state.
3.  **Removed Component-Level Shuffling:**
    *   Deleted the `useMemo` hook and the associated shuffling logic (`.sort(() => Math.random() - 0.5)`) from `MultipleChoiceQuestionComponent.tsx`.
    *   The component now directly uses the `options` array passed down via props, which is already in the correct (potentially pre-shuffled) order determined by the parent hook.

**Outcome:** MC question options are now shuffled only once at the beginning of a quiz or test attempt (if configured to do so). The shuffled order remains stable and consistent for the duration of the attempt, regardless of user navigation within the assessment.

# Task: Adjust Spaced Repetition Scheduling for Past Due Reviews

**Goal:** Ensure that when a user completes a review that was past its scheduled due date, the *next* review date is calculated based on the *current date* (the date of completion), not the original missed due date.

**Initial Problem:** The `calculateNextReviewDate` function always used the `previousDueDate` (the date stored in the database) as the base for adding the next interval. If this `previousDueDate` was in the past (e.g., 7 days ago), adding the next interval (e.g., 1 day) would result in a `nextReviewDate` that was still in the past (e.g., 6 days ago).

**Root Cause:** The calculation logic did not account for the possibility of the `previousDueDate` being before the actual date the review was performed.

**Specific Changes Implemented:**

**Backend (`backend/src/lib/spacedRepetition.ts`):

1.  **Modified `calculateNextReviewDate` Function:**
    *   Added logic to get the current date (`today`) normalized to the beginning of the day.
    *   Compared the `previousDueDate` (also normalized) to `today`.
    *   Set the `baseDate` for the interval calculation to `today` if `previousDueDate` was in the past.
    *   If `previousDueDate` was not provided or was not in the past, the `baseDate` remains `previousDueDate` (or defaults to `today` if `previousDueDate` was null).

**Outcome:** When completing overdue reviews, the next review date is now scheduled correctly relative to the date the review was actually completed, preventing newly scheduled reviews from being immediately overdue.
