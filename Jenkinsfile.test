pipeline {
    agent any

    options {
        timeout(time: 5, unit: 'MINUTES')
        disableConcurrentBuilds()
        quietPeriod(0)
        buildDiscarder(logRotator(numToKeepStr: '5'))
    }

    environment {
        EC2_HOST = '3.21.246.147'
        FRONTEND_PORT = '8085'
        BACKEND_PORT = '8000'
        NODE_ENV = 'test'
        API_URL = "http://${EC2_HOST}:${BACKEND_PORT}/api"
    }

    stages {
        stage('Setup Git') {
            steps {
                withCredentials([sshUserPrivateKey(
                    credentialsId: 'jenkins-ssh-key',
                    keyFileVariable: 'SSH_KEY'
                )]) {
                    sh '''
                        # Setup SSH directory
                        mkdir -p ~/.ssh
                        chmod 700 ~/.ssh
                        
                        # Add GitHub keys with all types
                        ssh-keyscan -t rsa,dsa,ecdsa,ed25519 github.com >> ~/.ssh/known_hosts
                        chmod 644 ~/.ssh/known_hosts
                        
                        # Copy SSH key
                        cp "$SSH_KEY" ~/.ssh/id_rsa
                        chmod 600 ~/.ssh/id_rsa
                        
                        # Test GitHub connection
                        ssh -T -o StrictHostKeyChecking=no git@github.com || true
                        
                        # Clean workspace
                        rm -rf .* * || true
                    '''
                }
            }
        }

        stage('Checkout') {
            steps {
                checkout([$class: 'GitSCM',
                    branches: [[name: '*/main']],
                    userRemoteConfigs: [[
                        url: 'git@github.com:cee8/codeladder.git',
                        credentialsId: 'jenkins-ssh-key'
                    ]]
                ])
            }
        }

        stage('Setup Environment') {
            steps {
                script {
                    withCredentials([
                        string(credentialsId: 'DATABASE_URL', variable: 'DATABASE_URL'),
                        string(credentialsId: 'JWT_SECRET', variable: 'JWT_SECRET'),
                        string(credentialsId: 'JWT_REFRESH_SECRET', variable: 'JWT_REFRESH_SECRET'),
                        string(credentialsId: 'AWS_ACCESS_KEY_ID', variable: 'AWS_ACCESS_KEY_ID'),
                        string(credentialsId: 'AWS_SECRET_ACCESS_KEY', variable: 'AWS_SECRET_ACCESS_KEY')
                    ]) {
                        sh """
                            cat > backend/.env.test << EOL
NODE_ENV=test
PORT=${BACKEND_PORT}
DATABASE_URL=${DATABASE_URL}
JWT_SECRET=${JWT_SECRET}
JWT_REFRESH_SECRET=${JWT_REFRESH_SECRET}
JWT_EXPIRES_IN=15m
CORS_ORIGIN=http://localhost:${FRONTEND_PORT}
AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
AWS_REGION=us-east-2
S3_BUCKET=codeladder-s3
EOL
                        """
                    }
                }
            }
        }

        stage('Test Backend') {
            steps {
                dir('backend') {
                    script {
                        // Setup test environment
                        sh '''
                            echo "üîÑ Setting up test environment..."
                            npm install
                            npm install --save-dev jest @types/jest ts-jest supertest @types/supertest
                        '''

                        // Update package.json with JSON output
                        sh '''
                            node -e '
                                const fs = require("fs");
                                const pkg = JSON.parse(fs.readFileSync("package.json", "utf8"));
                                pkg.scripts = pkg.scripts || {};
                                pkg.scripts.test = "jest --json --outputFile=jest-output.json";
                                fs.writeFileSync("package.json", JSON.stringify(pkg, null, 2));
                            '
                        '''

                        // Create test configs (tsconfig.json and jest.config.js remain the same)
                        sh '''
                            echo '{
                                "compilerOptions": {
                                    "target": "es6",
                                    "module": "commonjs",
                                    "types": ["jest", "node"],
                                    "esModuleInterop": true,
                                    "skipLibCheck": true,
                                    "forceConsistentCasingInFileNames": true
                                },
                                "include": ["src/**/*", "__tests__/**/*"],
                                "exclude": ["node_modules"]
                            }' > tsconfig.json

                            echo 'module.exports = {
                                preset: "ts-jest",
                                testEnvironment: "node",
                                testTimeout: 10000,
                                verbose: false,
                                collectCoverage: true
                            }' > jest.config.js
                        '''

                        // Create and run tests
                        sh '''
                            mkdir -p __tests__
                            echo 'import { describe, expect, test } from "@jest/globals";
                            describe("Health Check", () => {
                                test("Server is running", () => {
                                    expect(true).toBe(true);
                                });
                            });' > __tests__/health.test.ts
                            
                            npm test || true
                        '''

                        // Parse test results
                        def testResults = readJSON file: 'jest-output.json'
                        def numPassedTests = testResults.numPassedTests
                        def numFailedTests = testResults.numFailedTests
                        def numTotalTests = testResults.numTotalTests
                        def testDuration = (testResults.testResults.reduce { acc, val -> acc.perfStats.end > val.perfStats.end ? acc : val }.perfStats.end / 1000).round(2)

                        echo """‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                           TEST EXECUTION SUMMARY                           ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë ${numFailedTests == 0 ? '‚úÖ All Tests Passed' : '‚ùå Some Tests Failed'}                                                    ‚ïë
‚ïë                                                                           ‚ïë
‚ïë Total Tests: ${numTotalTests.toString().padRight(66)} ‚ïë
‚ïë Passed: ${numPassedTests.toString().padRight(69)} ‚ïë
‚ïë Failed: ${numFailedTests.toString().padRight(69)} ‚ïë
‚ïë Duration: ${testDuration}s${' '.multiply(67)}‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"""

                        if (numFailedTests > 0) {
                            def failedTests = testResults.testResults.findAll { it.status == 'failed' }
                            failedTests.each { result ->
                                echo "Failed Test: ${result.name}"
                                result.assertionResults.findAll { it.status == 'failed' }.each { assertion ->
                                    echo "  ‚ùå ${assertion.title}: ${assertion.failureMessages.join('\n     ')}"
                                }
                            }
                            error "Tests failed!"
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            cleanWs()
        }
        failure {
            echo "Tests failed on branch ${env.BRANCH_NAME ?: 'main'}"
        }
        success {
            echo "All tests passed on branch ${env.BRANCH_NAME ?: 'main'}"
        }
    }
} 